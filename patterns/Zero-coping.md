# Zero-coping (Избегание копирования)
 - Проблема: операции над "подмножествами" объектов (например, как подстрока у строки) требуют временного объекта, отображающего подмножество своего родительского объекта. Такие операции могут создавать множество коротко-живущих объектов. Например, string.Substring() или подмассивы массивов / подсписки списков.
 - Решение: введение нового типа, который позволяет нарезать объект - пердставляет подмножества объекта без копирования памяти. 
 - Преимущества: вы можете производить операции с подмножествами данных без дополнительных затрат на копирование памяти - особенно полезно в разных методах рекурсивного спуска и синтаксического анализа.
 - Последствия: API и код становится загрязнен специальными техническими типами.

## Span\<T\>
Это тип значений (ссылочная структура), поэтому сам по себе не влечет никакого выделения памяти. В нем определен индексатор, возвращающий значение по ссылке, поэтому его можно использовать как массив. Кроме того, он спроектирован так, чтобы можно было эффективно использовать поддиапазоны. Поддиапазон представляется другой ссылочной структурой Span<T>, которая также не требует выделения памяти.

### Regular arrays
### Stack allocated data
### Unmanaged memory
### Strings

Zero-coping slice
Последствия:
 - Span<T> contains managed pointer, it cannot appear on the Managed Heap
 - the main concern - async methods with their boxing state machines

## Memory\<T\>
Представляет непрерывную область произвольной памяти, но не является byref-подобным типом и  не содержит byref-подобных полей экземпляра. Стало быть, в отличие от Span\<T\>, этот тип может находиться в куче (хотя из соображений производительности он тоже является структурой, хоть и не ссылочной). Он может встречаться в полях обычных объектов, его можно использовать в асинхронных конечных автоматах и т. д. Запрещается оборачивать типом Memory\<T\> данные в стеке (например, полученные от stackalloc).

Other examples:
 - System.IO.Piplines
 - ref returning and argument passing